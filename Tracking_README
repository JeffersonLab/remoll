Tracking in the JeffersonLab/remoll/tracking_peri branch works as follows:

1) remoll is compiled and the macro tracking.mac is called which runs 100,000 events using the standard magnetic field and the geometry_dose files (can be changed in the macro) and either the beam, moller, or other generators (can be changed in the macro), and handler.sh can be used to run multiple parallel simulations to speed up analysis.
2) remollEventAction opens 9 files, one for the parent particles in any given event, and 1 for the first 8 daughters for each event. 
3) This class then checks for whether the particle ever hits the desired detector (presently detector number 28, the circular placeholder detector for the detector array - the beam vs moller vs other generators affects what signal reaches this detector, and the detector itself can be changed in size to further specify what kind of signal gets observed, these are all considerations which must go into the writing of the macro and the geometry files) and sets the event's "goodParticle" flag to yes or no.
4) The goodParticle flag is then is used to print to the appropriate mother or daughter file (after the event ends) a flag (x,y,z = -29,-29,-29 for good detector hit, and -37,-37,-37 for bad detector hits), and if it is a good particle the hit's energy and momentum are printed as well, in case that information is desired.
5) remollSteppingAction this whole time takes these same 9 files and prints the x,y,z coordinates at each step (with rudimentary kryptonite feature currently commented out -> should be added in in the next version).

(These first four steps are very crude and cause a very large amount of data to be written and slow down the execution of remoll significantly as opening and closing text files is not a quick process. It would be good to replace this functionality with a more advanced UserTrackAction/TrackingAction variable storage technique as exemplified in sbujlab/remoll/dose_track)

6) The large textfiles, largely full of bad hits (-37 flags), can then be parsed down into just the good hits by a rather ham-fisted approach shown in the other repository, cameronc137/auto_envelope, the root executable script peripheralPlotPoints_sep.c, which condenses all the seperate parent and daughter good hits into single file individual slices as a function of z position and also condenses the seven-fold symmetry down into one single envelope that is a seventh of the full array.
7) Then reader.c is used to read from those z position files and allow the user to place by hand individual guess vertex points that serve as starting guesses for the fitting algorithm, stored in vertices.txt.
8) Then the envelopeFitLoop_batch.c is called for each of the start points selected by the user in reader.c by the fithandler.sh script that uses gFit and the qsub system to submit all the fits at the same time.
